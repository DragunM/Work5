**Вариант 4. 0-1 Рюкзак с жадным алгоритмом**

**Задача**: реализовать жадный приближенный алгоритм для 0-1 рюкзака. Отличие от дробного
в том, что предметы нельзя дробить.

**Требования**:
- Реализовать 2-аппроксимационный жадный алгоритм
- Вывести список выбранных предметов и общую стоимость
- Указать коэффициент аппроксимации

**Входные данные**:
Предметы: {(вес=3, стоимость=12), (вес=2, стоимость=8),
(вес=4, стоимость=20), (вес=5, стоимость=18)}
Вместимость: 7

**Функция knapsack_01_greedy**:

   **Объявление временного вектора**: 
**vector<tuple<double, int, int, int>> items_with_ratio** - Создание вектора для хранения предметов с дополнительной информацией.

**Заполнение вектора с расчетом удельной стоимости**:

for (size_t i = 0; i < items.size(); i++) {

  double ratio = (double)items[i].second / items[i].first;
    
  items_with_ratio.push_back(make_tuple(ratio, i, items[i].first, items[i].second));
}

Для каждого предмета вычисляется удельная стоимость и сохраняется вместе с оригинальным индексом.

**Сортировка предметов**:

sort(items_with_ratio.begin(), items_with_ratio.end(), 

[](const tuple<double, int, int, int>& a, const tuple<double, int, int, int>& b) {
return get<0>(a) > get<0>(b);

Сортировка предметов по убыванию удельной стоимости с использованием лямбда-функции

**Инициализация переменных результатов**:

vector<pair<int, int>> selected_items;

int total_value = 0;

int total_weight = 0;

Подготовка переменных для накопления результатов

**Жадный выбор предметов**:

for (const auto& item : items_with_ratio) {

  double ratio = get<0>(item);
  
  int original_index = get<1>(item);
  
  int weight = get<2>(item);
  
  int value = get<3>(item);
    
  if (total_weight + weight <= capacity) 
  
  selected_items.push_back(items[original_index]);
  
 total_value += value;
 
 total_weight += weight;
    
Последовательный выбор предметов, которые помещаются в рюкзак

**Поиск максимального предмета**:

int max_single_value = 0;

for (const auto& item : items) {

  if (item.second > max_single_value && item.first <= capacity) 
  
  max_single_value = item.second;

  Нахождение предмета с максимальной стоимостью, который помещается в рюкзак
        
**Вычисление коэффициента аппроксимации**:

double approx_ratio;

if (total_value == 0) {

if (max_single_value == 0) {
    
  approx_ratio = 1.0;
        
  } else {
      approx_ratio = numeric_limits<double>::infinity();
      
  
    
  }  else {
    approx_ratio = (double)max(max_single_value, total_value) / total_value;

approx_ratio = min(approx_ratio, 2.0);

Расчет и гарантирование коэффициента аппроксимации ≤ 2.0


**Функция main**

**Инициализация данных**:

vector<pair<int, int>> items = {{3, 12}, {2, 8}, {4, 20}, {5, 18}};

int capacity = 7;

Определение тестовых входных данных


**Вызов алгоритма**

**auto [selected_items, total_value, approx_ratio] = knapsack_01_greedy(items, capacity)** - Structured binding (C++17) для распаковки возвращаемых значений.

**Вывод результатов**

cout << "=== ЖАДНЫЙ АЛГОРИТМ ДЛЯ 0-1 РЮКЗАКА ===" << endl;

// ... вывод информации ...

Форматированный вывод всех результатов работы алгоритма.

**Временная сложность**:  **O(n log n)**

**Почему**  **O(n log n)**: 

O(n log n) растет быстрее, чем O(n):

При n = 1000: O(n) = 1000, O(n log n) ≈ 10000

При n = 10000: O(n) = 10000, O(n log n) ≈ 140000

**Сортировка** - самая дорогая операция в алгоритме.

**Контрольный вопрос**: Почему жадный алгоритм для задачи о вершинном покрытии дает 2-аппроксимацию? Приведите доказательство.

**Доказательство 2-аппроксимации**

**Шаг 1**: Корректность алгоритма

Утверждение: Алгоритм возвращает вершинное покрытие.

Доказательство:

На каждой итерации выбирается ребро (u, v) и добавляются обе вершины в покрытие

Удаляются все ребра, инцидентные u или v

Цикл продолжается, пока есть непокрытые ребра

Следовательно, в конце все ребра покрыты

**Шаг 2**: Анализ размера покрытия

Обозначения:

C - покрытие, найденное алгоритмом

C* - оптимальное покрытие

A = {(u₁,v₁), (u₂,v₂), ..., (uₖ,vₖ)} - множество ребер, выбранных алгоритмом

**Лемма 1**: Множество A является паросочетанием (matching).

Доказательство:

Ребра в A не имеют общих вершин

После выбора ребра (uᵢ, vᵢ) удаляются все ребра, инцидентные uᵢ или vᵢ

Следовательно, следующие выбранные ребра не могут иметь общих вершин с предыдущими

**Лемма 2**: |C| = 2|A|

Доказательство:

На каждом шаге добавляется 2 вершины

Количество шагов = |A|

Следовательно, |C| = 2|A|

**Шаг 3**: Связь с оптимальным покрытием

Лемма 3: |A| ≤ |C*|

Доказательство:

A - паросочетание (ребра не имеют общих вершин)

Любое вершинное покрытие должно содержать хотя бы одну вершину из каждого ребра паросочетания

Следовательно, |C*| ≥ |A|

**Шаг 4**: Заключительное неравенство

Из лемм 2 и 3:

|C| = 2|A| ≤ 2|C*|

Следовательно:


|C| ≤ 2|C*|
